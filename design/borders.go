package design

import "github.com/20kdc/CCUpdaterUI/frenyard"

/*
 * Before continuing, further details on how this module specifically works must be provided.
 * 
 * Firstly, it is to be understood that SDL2 Renderer DOES NOT support mipmapping.
 * It may supposedly support linear upscaling but in practice I have not found this to be working.
 * 
 * Furthermore, it'd be nice to be able to upscale the assets in future.
 * As such.
 * 
 * Ninepatches for this module are typically drawn by usage of a browser showing a special HTML page.
 * This is because a lot of elements from MD, which we're mimicking for continuity with the website, are designed assuming CSS box-shadow support.
 * Which we do not have.
 * 
 * The informal standard I've made up for this uses a "reference size" of a 32x32 image, with the component within a 16x16 centred square.
 * The units here are expected to match browser "px" units in a 1:1 px-to-real-pixel environment.
 * Images are then postfixed with a multiplier. "X4" is presently the 'standard' here.
 * The images are then automatically *downscaled* as necessary.
 */

var borderButtonTexture frenyard.Texture
var borderButtonShadowTexture frenyard.Texture
var borderButtonShadowFocusTexture frenyard.Texture
var borderHeaderTexture frenyard.Texture
var borderImageScale int32
var borderEffectiveScale float64

func deSetupBorders() {
	// This must all be kept in sync!
	
	borderImageScale = 4
	
	buttonImage := frenyard.CreateHardcodedPNGImage(borderButtonX4B64)
	buttonShadowImage := frenyard.CreateHardcodedPNGImage(borderButtonShadowX4B64)
	buttonShadowFocusImage := frenyard.CreateHardcodedPNGImage(borderButtonShadowFocusX4B64)
	headerImage := frenyard.CreateHardcodedPNGImage(borderHeaderCompositeX4B64)
	
	borderEffectiveScale = DesignScale / float64(borderImageScale)
	
	for borderImageScale > 1 && borderEffectiveScale <= 0.5 {
		borderEffectiveScale *= 2
		borderImageScale /= 2
		
		buttonImage = frenyard.ScaleImageToHalfSize(buttonImage)
		buttonShadowImage = frenyard.ScaleImageToHalfSize(buttonShadowImage)
		buttonShadowFocusImage = frenyard.ScaleImageToHalfSize(buttonShadowFocusImage)
		headerImage = frenyard.ScaleImageToHalfSize(headerImage)
	}
	
	borderButtonTexture = frenyard.GoImageToTexture(buttonImage, []frenyard.ColourTransform{frenyard.ColourTransformBlueToStencil})
	borderButtonShadowTexture = frenyard.GoImageToTexture(buttonShadowImage, []frenyard.ColourTransform{frenyard.ColourTransformInvert, frenyard.ColourTransformBlueToStencil, frenyard.ColourTransformInvert})
	borderButtonShadowFocusTexture = frenyard.GoImageToTexture(buttonShadowFocusImage, []frenyard.ColourTransform{frenyard.ColourTransformInvert, frenyard.ColourTransformBlueToStencil, frenyard.ColourTransformInvert})
	borderHeaderTexture = frenyard.GoImageToTexture(headerImage, []frenyard.ColourTransform{})
}

// Returns a "standard ninepatch" for the autogenerated stuff.
// 'n' represents the bounds <-> centre margin in prescaled units.
func designStandardBorderNinepatch(base frenyard.NinePatch, n int32) frenyard.NinePatch {
	base.Sprite = frenyard.Area2iFromVecs(frenyard.Vec2i{X: 0, Y: 0}, frenyard.Vec2i{X: 32 * borderImageScale, Y: 32 * borderImageScale})
	base.Bounds = frenyard.Area2iFromVecs(frenyard.Vec2i{X: 8 * borderImageScale, Y: 8 * borderImageScale}, frenyard.Vec2i{X: 16 * borderImageScale, Y: 16 * borderImageScale})
	base.Centre = frenyard.Area2iFromVecs(frenyard.Vec2i{X: (8 + n) * borderImageScale, Y: (8 + n) * borderImageScale}, frenyard.Vec2i{X: (16 - (n * 2)) * borderImageScale, Y: (16 - (n * 2)) * borderImageScale})
	return base
}

// BorderButton creates a border for a button of a given background colour.
func BorderButton(colour uint32, focus bool) frenyard.NinePatchPackage {
	addedBorderX := int32(12) * borderImageScale
	addedBorderY := int32(8) * borderImageScale
	shadowType := borderButtonShadowTexture
	if focus {
		shadowType = borderButtonShadowFocusTexture
	}
	return frenyard.NinePatchPackage{
		Under: designStandardBorderNinepatch(frenyard.NinePatch{
			Tex:       shadowType,
			ColourMod: colour,
		}, 4),
		Over: designStandardBorderNinepatch(frenyard.NinePatch{
			Tex:       borderButtonTexture,
			ColourMod: colour,
		}, 4),
		Padding:  frenyard.Area2iFromVecs(frenyard.Vec2i{X: -addedBorderX, Y: -addedBorderY}, frenyard.Vec2i{X: addedBorderX * 2, Y: addedBorderY * 2}),
		Scale: borderEffectiveScale,
		Clipping: true,
	}
}

// This border deliberately "hangs over" on the OVER layer.
// With correct manipulation of Z (ensure title is LAST in flexbox & use Order to correct)
// this produces a shadow effect that even hangs over other UI.

// BorderTitle produces a border for the shadowing effect under a title.
func BorderTitle(colour uint32) frenyard.NinePatchPackage {
	addedBorderX := int32(8) * borderImageScale
	addedBorderY := int32(8) * borderImageScale
	return frenyard.NinePatchPackage{
		Over: designStandardBorderNinepatch(frenyard.NinePatch{
			Tex:       borderHeaderTexture,
			ColourMod: colour,
		}, 4),
		Padding:  frenyard.Area2iFromVecs(frenyard.Vec2i{X: -addedBorderX, Y: -addedBorderY}, frenyard.Vec2i{X: addedBorderX * 2, Y: addedBorderY * 2}),
		Scale: borderEffectiveScale,
		Clipping: true,
	}
}
